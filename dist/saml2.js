// Generated by CoffeeScript 1.7.1
var IdentityProvider, ServiceProvider, XMLNS, async, certificate_to_keyinfo, check_saml_signature, check_status_success, create_authn_request, create_logout_request, create_metadata, crypto, debug, decrypt_assertion, format_pem, get_name_id, get_session_index, parseString, parse_assertion_attributes, parse_authn_response, parse_response_header, pretty_assertion_attributes, sign_get_request, to_error, url, util, xmlbuilder, xmlcrypto, xmldom, xmlenc, zlib, _,
  __slice = [].slice,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

_ = require('underscore');

async = _.extend(require('async'), require('async-ext'));

crypto = require('crypto');

debug = require('debug')('saml2');

parseString = require('xml2js').parseString;

url = require('url');

util = require('util');

xmlbuilder = require('xmlbuilder');

xmlcrypto = require('xml-crypto');

xmldom = require('xmldom');

xmlenc = require('xml-encryption');

zlib = require('zlib');

XMLNS = {
  SAML: 'urn:oasis:names:tc:SAML:2.0:assertion',
  SAMLP: 'urn:oasis:names:tc:SAML:2.0:protocol',
  MD: 'urn:oasis:names:tc:SAML:2.0:metadata',
  DS: 'http://www.w3.org/2000/09/xmldsig#',
  XENC: 'http://www.w3.org/2001/04/xmlenc#'
};

create_authn_request = function(issuer, assert_endpoint, destination) {
  var id, xml;
  id = '_' + crypto.randomBytes(21).toString('hex');
  xml = xmlbuilder.create({
    AuthnRequest: {
      '@xmlns': XMLNS.SAMLP,
      '@xmlns:saml': XMLNS.SAML,
      '@Version': '2.0',
      '@ID': id,
      '@IssueInstant': (new Date()).toISOString(),
      '@Destination': destination,
      '@AssertionConsumerServiceURL': assert_endpoint,
      '@ProtocolBinding': 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST',
      'saml:Issuer': issuer,
      NameIDPolicy: {
        '@Format': 'urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified',
        '@AllowCreate': 'true'
      }
    }
  }).end();
  return {
    id: id,
    xml: xml
  };
};

create_metadata = function(issuer, assert_endpoint, signing_certificate, encryption_certificate) {
  return xmlbuilder.create({
    'md:EntityDescriptor': {
      '@xmlns:md': XMLNS.MD,
      '@xmlns:ds': XMLNS.DS,
      '@entityID': issuer,
      'md:SPSSODescriptor': [
        {
          '@protocolSupportEnumeration': 'urn:oasis:names:tc:SAML:1.1:protocol urn:oasis:names:tc:SAML:2.0:protocol'
        }, {
          'md:KeyDescriptor': certificate_to_keyinfo('signing', signing_certificate)
        }, {
          'md:KeyDescriptor': certificate_to_keyinfo('encryption', encryption_certificate)
        }, {
          'md:AssertionConsumerService': {
            '@Binding': 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST',
            '@Location': assert_endpoint,
            '@index': '0'
          },
          'md:SingleLogoutService': {
            '@Binding': 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect',
            '@Location': assert_endpoint
          }
        }
      ]
    }
  }).end();
};

create_logout_request = function(issuer, name_id, session_index, destination) {
  return xmlbuilder.create({
    'samlp:LogoutRequest': {
      '@xmlns:samlp': XMLNS.SAMLP,
      '@xmlns:saml': XMLNS.SAML,
      '@ID': '_' + crypto.randomBytes(21).toString('hex'),
      '@Version': '2.0',
      '@IssueInstant': (new Date()).toISOString(),
      '@Destination': destination,
      'saml:Issuer': issuer,
      'saml:NameID': name_id,
      'samlp:SessionIndex': session_index
    }
  }).end();
};

format_pem = function(key, type) {
  if ((/-----BEGIN [0-9A-Z ]+-----[^-]*-----END [0-9A-Z ]+-----/g.exec(key)) != null) {
    return key;
  }
  return ("-----BEGIN " + (type.toUpperCase()) + "-----\n") + key.match(/.{1,64}/g).join("\n") + ("\n-----END " + (type.toUpperCase()) + "-----");
};

sign_get_request = function(saml_request, private_key) {
  var data, sign;
  data = "SAMLRequest=" + encodeURIComponent(saml_request) + "&SigAlg=" + encodeURIComponent('http://www.w3.org/2001/04/xmldsig-more#rsa-sha256');
  sign = crypto.createSign('RSA-SHA256');
  sign.update(data);
  return {
    SAMLRequest: saml_request,
    SigAlg: 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha256',
    Signature: sign.sign(format_pem(private_key, 'PRIVATE KEY'), 'base64')
  };
};

certificate_to_keyinfo = function(use, certificate) {
  var cert_data;
  cert_data = /-----BEGIN CERTIFICATE-----([^-]*)-----END CERTIFICATE-----/g.exec(certificate);
  cert_data = cert_data != null ? cert_data[1] : certificate;
  if (cert_data == null) {
    throw new Error('Invalid Certificate');
  }
  return {
    '@use': use,
    'ds:KeyInfo': {
      '@xmlns:ds': XMLNS.DS,
      'ds:X509Data': {
        'ds:X509Certificate': cert_data.replace(/[\r\n|\n]/g, '')
      }
    }
  };
};

check_saml_signature = function(xml, certificate, cb) {
  var doc, sig, signature;
  doc = (new xmldom.DOMParser()).parseFromString(xml);
  signature = xmlcrypto.xpath(doc, "/*/*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']");
  if (signature.length !== 1) {
    return false;
  }
  sig = new xmlcrypto.SignedXml();
  sig.keyInfoProvider = {
    getKey: function() {
      return format_pem(certificate, 'CERTIFICATE');
    }
  };
  sig.loadSignature(signature[0].toString());
  return sig.checkSignature(xml);
};

check_status_success = function(dom) {
  var attr, status, status_code, _i, _j, _len, _len1, _ref, _ref1;
  status = dom.getElementsByTagNameNS(XMLNS.SAMLP, 'Status');
  if (status.length !== 1) {
    return false;
  }
  _ref = status[0].childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    status_code = _ref[_i];
    if (status_code.attributes != null) {
      _ref1 = status_code.attributes;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        attr = _ref1[_j];
        if (attr.name === 'Value' && attr.value === 'urn:oasis:names:tc:SAML:2.0:status:Success') {
          return true;
        }
      }
    }
  }
  return false;
};

to_error = function(err) {
  if (err == null) {
    return null;
  }
  if (!(err instanceof Error)) {
    return new Error(util.inspect(err));
  }
  return err;
};

decrypt_assertion = function(dom, private_key, cb) {
  var encrypted_assertion, encrypted_data, err;
  cb = _.wrap(cb, function() {
    var args, err, fn;
    fn = arguments[0], err = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return setTimeout((function() {
      return fn.apply(null, [to_error(err)].concat(__slice.call(args)));
    }), 0);
  });
  try {
    encrypted_assertion = dom.getElementsByTagNameNS(XMLNS.SAML, 'EncryptedAssertion');
    if (encrypted_assertion.length !== 1) {
      return cb(new Error("Expected 1 EncryptedAssertion; found " + encrypted_assertion.length + "."));
    }
    encrypted_data = encrypted_assertion[0].getElementsByTagNameNS(XMLNS.XENC, 'EncryptedData');
    if (encrypted_data.length !== 1) {
      return cb(new Error("Expected 1 EncryptedData inside EncryptedAssertion; found " + encrypted_data.length + "."));
    }
    return xmlenc.decrypt(encrypted_data[0].toString(), {
      key: format_pem(private_key, 'PRIVATE KEY')
    }, cb);
  } catch (_error) {
    err = _error;
    return cb(new Error("Decrypt failed: " + (util.inspect(err))));
  }
};

parse_response_header = function(dom) {
  var attr, response, response_header, response_type, _i, _j, _len, _len1, _ref, _ref1;
  _ref = ['Response', 'LogoutResponse'];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    response_type = _ref[_i];
    response = dom.getElementsByTagNameNS(XMLNS.SAMLP, response_type);
    if (response.length > 0) {
      break;
    }
  }
  if (response.length !== 1) {
    throw new Error("Expected 1 Response; found " + response.length);
  }
  response_header = {};
  _ref1 = response[0].attributes;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    attr = _ref1[_j];
    switch (attr.name) {
      case "Version":
        if (attr.value !== "2.0") {
          throw new Error("Invalid SAML Version " + attr.value);
        }
        break;
      case "Destination":
        response_header.destination = attr.value;
        break;
      case "InResponseTo":
        response_header.in_response_to = attr.value;
    }
  }
  return response_header;
};

get_name_id = function(dom) {
  var assertion, nameid, subject, _ref;
  assertion = dom.getElementsByTagNameNS(XMLNS.SAML, 'Assertion');
  if (assertion.length !== 1) {
    throw new Error("Expected 1 Assertion; found " + assertion.length);
  }
  subject = assertion[0].getElementsByTagNameNS(XMLNS.SAML, 'Subject');
  if (subject.length !== 1) {
    throw new Error("Expected 1 Subject; found " + subject.length);
  }
  nameid = subject[0].getElementsByTagNameNS(XMLNS.SAML, 'NameID');
  if (nameid.length !== 1) {
    return null;
  }
  return (_ref = nameid[0].firstChild) != null ? _ref.data : void 0;
};

get_session_index = function(dom) {
  var assertion, attr, authn_statement, _i, _len, _ref;
  assertion = dom.getElementsByTagNameNS(XMLNS.SAML, 'Assertion');
  if (assertion.length !== 1) {
    throw new Error("Expected 1 Assertion; found " + assertion.length);
  }
  authn_statement = assertion[0].getElementsByTagNameNS(XMLNS.SAML, 'AuthnStatement');
  if (authn_statement.length !== 1) {
    throw new Error("Expected 1 AuthnStatement; found " + authn_statement.length);
  }
  _ref = authn_statement[0].attributes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    attr = _ref[_i];
    if (attr.name === 'SessionIndex') {
      return attr.value;
    }
  }
  throw new Error("SessionIndex not an attribute of AuthnStatement.");
};

parse_assertion_attributes = function(dom) {
  var assertion, assertion_attributes, attr, attribute, attribute_name, attribute_statement, _i, _j, _len, _len1, _ref, _ref1;
  assertion = dom.getElementsByTagNameNS(XMLNS.SAML, 'Assertion');
  if (assertion.length !== 1) {
    throw new Error("Expected 1 Assertion; found " + assertion.length);
  }
  attribute_statement = assertion[0].getElementsByTagNameNS(XMLNS.SAML, 'AttributeStatement');
  if (!(attribute_statement.length <= 1)) {
    throw new Error("Expected 1 AttributeStatement inside Assertion; found " + attribute_statement.length);
  }
  if (attribute_statement.length === 0) {
    return {};
  }
  assertion_attributes = {};
  _ref = attribute_statement[0].getElementsByTagNameNS(XMLNS.SAML, 'Attribute');
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    attribute = _ref[_i];
    _ref1 = attribute.attributes;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      attr = _ref1[_j];
      if (attr.name === 'Name') {
        attribute_name = attr.value;
      }
    }
    if (attribute_name == null) {
      throw new Error("Invalid attribute without name");
    }
    assertion_attributes[attribute_name] = _(attribute.getElementsByTagNameNS(XMLNS.SAML, 'AttributeValue')).map(function(attribute_value) {
      return attribute_value.childNodes[0].data;
    });
  }
  return assertion_attributes;
};

pretty_assertion_attributes = function(assertion_attributes) {
  var claim_map;
  claim_map = {
    "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress": "email",
    "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname": "given_name",
    "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name": "name",
    "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn": "upn",
    "http://schemas.xmlsoap.org/claims/CommonName": "common_name",
    "http://schemas.xmlsoap.org/claims/Group": "group",
    "http://schemas.microsoft.com/ws/2008/06/identity/claims/role": "role",
    "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname": "surname",
    "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/privatepersonalidentifier": "ppid",
    "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier": "name_id",
    "http://schemas.microsoft.com/ws/2008/06/identity/claims/authenticationmethod": "authentication_method",
    "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/denyonlysid": "deny_only_group_sid",
    "http://schemas.microsoft.com/ws/2008/06/identity/claims/denyonlyprimarysid": "deny_only_primary_sid",
    "http://schemas.microsoft.com/ws/2008/06/identity/claims/denyonlyprimarygroupsid": "deny_only_primary_group_sid",
    "http://schemas.microsoft.com/ws/2008/06/identity/claims/groupsid": "group_sid",
    "http://schemas.microsoft.com/ws/2008/06/identity/claims/primarygroupsid": "primary_group_sid",
    "http://schemas.microsoft.com/ws/2008/06/identity/claims/primarysid": "primary_sid",
    "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsaccountname": "windows_account_name"
  };
  return _(assertion_attributes).chain().pairs().filter(function(_arg) {
    var k, v;
    k = _arg[0], v = _arg[1];
    return (claim_map[k] != null) && v.length > 0;
  }).map(function(_arg) {
    var k, v;
    k = _arg[0], v = _arg[1];
    return [claim_map[k], v[0]];
  }).object().value();
};

parse_authn_response = function(saml_response, sp_private_key, idp_certificates, cb) {
  var decrypted_assertion, user;
  user = {};
  decrypted_assertion = null;
  return async.waterfall([
    function(cb_wf) {
      return decrypt_assertion(saml_response, sp_private_key, cb_wf);
    }, function(result, cb_wf) {
      debug(result);
      decrypted_assertion = (new xmldom.DOMParser()).parseFromString(result);
      if (!_.some(idp_certificates, function(cert) {
        return check_saml_signature(result, cert);
      })) {
        return cb_wf(new Error("SAML Assertion signature check failed! (checked " + idp_certificates.length + " certificate(s))"));
      }
      return cb_wf(null);
    }, function(cb_wf) {
      return async.lift(get_name_id)(decrypted_assertion, cb_wf);
    }, function(name_id, cb_wf) {
      user.name_id = name_id;
      return async.lift(get_session_index)(decrypted_assertion, cb_wf);
    }, function(session_index, cb_wf) {
      user.session_index = session_index;
      return async.lift(parse_assertion_attributes)(decrypted_assertion, cb_wf);
    }, function(assertion_attributes, cb_wf) {
      user = _.extend(user, pretty_assertion_attributes(assertion_attributes));
      user = _.extend(user, {
        attributes: assertion_attributes
      });
      return cb_wf(null, {
        user: user
      });
    }
  ], cb);
};

module.exports.ServiceProvider = ServiceProvider = (function() {
  function ServiceProvider(issuer, private_key, certificate) {
    this.issuer = issuer;
    this.private_key = private_key;
    this.certificate = certificate;
    this.create_metadata = __bind(this.create_metadata, this);
    this.create_logout_url = __bind(this.create_logout_url, this);
    this.create_login_url = __bind(this.create_login_url, this);
  }

  ServiceProvider.prototype.create_login_url = function(identity_provider, assert_endpoint, cb) {
    var id, xml, _ref;
    _ref = create_authn_request(this.issuer, assert_endpoint, identity_provider.sso_login_url), id = _ref.id, xml = _ref.xml;
    return zlib.deflateRaw(xml, function(err, deflated) {
      var uri;
      if (err != null) {
        return cb(err);
      }
      uri = url.parse(identity_provider.sso_login_url);
      uri.query = {
        SAMLRequest: deflated.toString('base64')
      };
      return cb(null, url.format(uri), id);
    });
  };

  ServiceProvider.prototype.assert = function() {
    var cb, decrypted_assertion, get_request, identity_provider, request_body, response, saml_response, _i;
    identity_provider = arguments[0], request_body = arguments[1], get_request = 4 <= arguments.length ? __slice.call(arguments, 2, _i = arguments.length - 1) : (_i = 2, []), cb = arguments[_i++];
    get_request = get_request[0];
    if ((request_body != null ? request_body.SAMLResponse : void 0) == null) {
      return setImmediate(cb, new Error("Request body does not contain SAMLResponse."));
    }
    saml_response = null;
    decrypted_assertion = null;
    response = {};
    return async.waterfall([
      function(cb_wf) {
        var raw;
        raw = new Buffer(request_body.SAMLResponse, 'base64');
        if (get_request) {
          return zlib.inflateRaw(raw, cb_wf);
        }
        return setImmediate(cb_wf, null, raw);
      }, function(response_buffer, cb_wf) {
        debug(saml_response);
        saml_response = (new xmldom.DOMParser()).parseFromString(response_buffer.toString());
        return async.lift(parse_response_header)(saml_response, cb_wf);
      }, (function(_this) {
        return function(response_header, cb_wf) {
          response = {
            response_header: response_header
          };
          if (!check_status_success(saml_response)) {
            cb_wf(new Error("SAML Response was not success!"));
          }
          switch (false) {
            case saml_response.getElementsByTagNameNS(XMLNS.SAMLP, 'Response').length !== 1:
              response.type = 'authn_response';
              return parse_authn_response(saml_response, _this.private_key, identity_provider.certificates, cb_wf);
            case saml_response.getElementsByTagNameNS(XMLNS.SAMLP, 'LogoutResponse').length !== 1:
              response.type = 'logout_response';
              return setImmediate(cb_wf, null, {});
          }
        };
      })(this), function(result, cb_wf) {
        _.extend(response, result);
        return cb_wf(null, response);
      }
    ], cb);
  };

  ServiceProvider.prototype.create_logout_url = function(identity_provider, name_id, session_index, cb) {
    var xml;
    xml = create_logout_request(this.issuer, name_id, session_index, identity_provider.sso_logout_url);
    return zlib.deflateRaw(xml, (function(_this) {
      return function(err, deflated) {
        var uri;
        if (err != null) {
          return cb(err);
        }
        uri = url.parse(identity_provider.sso_logout_url);
        uri.query = sign_get_request(deflated.toString('base64'), _this.private_key);
        return cb(null, url.format(uri));
      };
    })(this));
  };

  ServiceProvider.prototype.create_metadata = function(assert_endpoint) {
    return create_metadata(this.issuer, assert_endpoint, this.certificate, this.certificate);
  };

  return ServiceProvider;

})();

module.exports.IdentityProvider = IdentityProvider = (function() {
  function IdentityProvider(sso_login_url, sso_logout_url, certificates) {
    this.sso_login_url = sso_login_url;
    this.sso_logout_url = sso_logout_url;
    this.certificates = certificates;
    if (!_.isArray(this.certificates)) {
      this.certificates = [this.certificates];
    }
  }

  return IdentityProvider;

})();

if (process.env.NODE_ENV === "test") {
  module.exports.create_authn_request = create_authn_request;
  module.exports.create_metadata = create_metadata;
  module.exports.format_pem = format_pem;
  module.exports.sign_get_request = sign_get_request;
  module.exports.check_saml_signature = check_saml_signature;
  module.exports.check_status_success = check_status_success;
  module.exports.decrypt_assertion = decrypt_assertion;
  module.exports.parse_response_header = parse_response_header;
  module.exports.parse_assertion_attributes = parse_assertion_attributes;
  module.exports.get_name_id = get_name_id;
  module.exports.get_session_index = get_session_index;
  module.exports.pretty_assertion_attributes = pretty_assertion_attributes;
}
